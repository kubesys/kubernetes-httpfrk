/**
 * Copyrigt (2019, ) Institute of Software, Chinese Academy of Sciences
 */
package com.github.kubesys.tools.generators;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.validation.Valid;
import javax.validation.constraints.AssertFalse;
import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.DecimalMax;
import javax.validation.constraints.DecimalMin;
import javax.validation.constraints.Digits;
import javax.validation.constraints.Future;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Null;
import javax.validation.constraints.Past;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

import org.springframework.beans.factory.annotation.Autowired;

import com.github.kubesys.httpfrk.core.HttpBodyHandler;
import com.github.kubesys.tools.utils.FileUtils;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;

/**
 * @author wuheng
 * @since 2021.1.13
 * 
 *  mysqldump -h 127.0.0.1 -uroot -ponceas demo user -- dbname_users.sql
 *  
 * 数据类型 	指定值和范围<br>
 * char 	      String(0~255) <br>
 * varchar 	      String(0~255) <br>
 * tinytext 	  String(0~255) <br>
 * text 	      String(0~65536) <br>
 * blob 	      String(0~65536) <br>
 * mediumtext 	  String(0~16777215) <br>
 * mediumblob 	  String(0~16777215) <br>
 * longblob 	  String(0~4294967295) <br>
 * longtext 	  String(0~4294967295) <br>
 * tinyint 	      Integer(-128~127) <br>
 * smallint 	  Integer(-32768~32767) <br>
 * mediumint 	  Integer(-8388608~8388607) <br>
 * int 	          Integer(-214847668~214847667) <br>
 * bigint 	      Integer(-9223372036854775808~9223372036854775807) <br>
 * float 	      decimal(精确到23位小数) <br>
 * double 	      decimal(24~54位小数) <br>
 * decimal 	          将double转储为字符串形式 <br>
 * date 	      YYYY-MM-DD <br>
 * datetime 	  YYYY-MM-DD HH:MM:SS <br>
 * timestamp 	  YYYYMMDDHHMMSS <br>
 * time 	      HH:MM:SS <br>
 * enum 	          选项值之一 <br>
 * set 	                 选项值子集 <br>
 * boolean 	      tinyint(1) <br>
 *  
 *  
 *  
 *  JSR 303
 *  
 *  Constraint	                                         详细信息
 *   Null	                                           被注释的元素必须为 null
 *   NotNull	                                    被注释的元素必须不为 null
 *   AssertTrue	                                    被注释的元素必须为 true
 *   AssertFalse	                             被注释的元素必须为 false
 *   Min(value)	                                    被注释的元素必须是一个数字，其值必须大于等于指定的最小值
 *   Max(value)	                                    被注释的元素必须是一个数字，其值必须小于等于指定的最大值
 *   DecimalMin(value)	                      被注释的元素必须是一个数字，其值必须大于等于指定的最小值
 *   DecimalMax(value)	                      被注释的元素必须是一个数字，其值必须小于等于指定的最大值
 *   Size(max, min)	                              被注释的元素的大小必须在指定的范围内
 *   Digits (integer, fraction)	        被注释的元素必须是一个数字，其值必须在可接受的范围内
 *   Past	                                            被注释的元素必须是一个过去的日期
 *   Future	                                            被注释的元素必须是一个将来的日期
 *   Pattern(value)	                              被注释的元素必须符合指定的正则表达式
 *   Email	                                            被注释的元素必须是电子邮箱地址
 *   Length	                                            被注释的字符串的大小必须在指定的范围内
 *   NotEmpty	                                     被注释的字符串的必须非空
 *   Range	                                            被注释的元素必须在合适的范围内
 */

public class ServiceGenerator {
	
public static final String rootPath = System.getProperty("user.dir");
	
	protected StringBuffer content = new StringBuffer();
	
	protected String dir;
	
	protected String name;
	
	public String getDir() {
		return dir;
	}

	public void setDir(String dir) {
		this.dir = dir;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void print() {
		System.out.println(content);
	}
	
	public void write() throws Exception {
		FileUtils.createFile(rootPath + "/" 
					+ dir.replace(".", "/"), 
					name, content.toString());
	}
	
	
	
	public static final String COPYRIGHT  = "/**\r\n" + 
				" * Copyrigt (2020, ) Institute of Software, Chinese Academy of Sciences\r\n" + 
				" */\n";
	
	public static final String PACKAGE    = "package PACKAGE_NAME;\n\n";
	
	public static final String IMPORT     = "import IMPORT_NAME;\n";
	
	public static final String CLASS      = "/**\r\n" + 
			" * This code is auto-generated by <code>ServiceGenerator<code>\r\n" + 
			" *\r\n" + " */\n@ServiceDefinition\n"
			+ "public class CLASS_NAME extends HttpBodyHandler {\n\n";
	
	public static final String FIELD      = "\t@Autowired\n\tprivate FIELD_TYPE FIELD_NAME;\n\n";
	
	public static final String METHOD     = "\tpublic METHOD_TYPE METHOD_NAME(";
	
	public static final String PROXY      = "PROXY_NAME.PROXY_METHOD(PROXY_PARAM)";
	
	public static final String FULLPROXY      = "java.util.Map<String, Object>  map = new java.util.HashMap<String, Object>();\r\n" + 
								"\t\tint from = (page - 1)*number;\r\n" + 
								"\t\tint to = page*number;\r\n" + 
								"\t\tmap.put(\"total\", TARGET.TOTAL_NUMBER);\r\n" + 
								"\t\tmap.put(\"data\", TARGET.TOTAK_DATA);\r\n" + 
								"\t\treturn map";
	
	public static final String RETURN     = "\t\treturn ";
	
	public static final String VOID       = "\t\t ";
	
	public static final String END_PARAM  = ") {\n";
	
	public static final String END_CLASS  = "}";
	
	public static final String END_METHOD = ";\n\t}\n\n";
	
	protected List<String> importList = new ArrayList<String>();
	
	protected String pkgName;
	
	protected Class<?> modelClass;
	
	
	public String getPkgName() {
		return pkgName;
	}

	public void setPkgName(String pkgName) {
		this.pkgName = pkgName;
	}

	public Class<?> getModelClass() {
		return modelClass;
	}

	public void setModelClass(Class<?> modelClass) {
		this.modelClass = modelClass;
	}

	/*******************************************
	 * 
	 *    Core 
	 * 
	 *******************************************/
	/**
	 * @param classname                     clz
	 * @throws Exception                    exception
	 */
	public void createServiceFromMapper(String classname) throws Exception {
		createServiceFromMapper(Class.forName(classname));
	}
	
	/**
	 * @param clazz                          clz
	 * @throws Exception                     exception
	 */
	public void createServiceFromMapper(Class<?> clazz) throws Exception {
		String serviceName = getServiceName(clazz);
		
		initImportList(clazz);
		StringBuffer genrateMethods = genrateMethods(clazz);
		
		content.append(COPYRIGHT);
		content.append(PACKAGE.replace("PACKAGE_NAME", this.getPkgName()));
		content.append(getImports()).append("\n");
		content.append(CLASS.replace("CLASS_NAME", serviceName));
		content.append(FIELD.replace("FIELD_TYPE", clazz.getSimpleName()).replace("FIELD_NAME", fieldName(clazz)));
		content.append(genrateMethods);
		content.append(END_CLASS);
	}

	/**
	 * @param clazz                        clz
	 * @return                             name
	 * @throws Exception                   exception
	 */
	protected String getServiceName(Class<?> clazz) throws Exception {
		String mapperPackage = clazz.getPackage().getName();
		String parentPackage = mapperPackage.substring(0, mapperPackage.lastIndexOf("."));
		this.setPkgName(parentPackage + ".services");
		this.setDir("/src/main/java/" + parentPackage + ".services"); 
		String serviceName = clazz.getSimpleName().replace("Mapper", "Service");
		this.setName(serviceName + ".java");
		String modelName = clazz.getSimpleName().replace("Mapper", "");
		this.setModelClass(Class.forName(parentPackage + ".models." + modelName));
		return serviceName;
	}


	/*******************************************
	 * 
	 *    Import 
	 * 
	 *******************************************/
	
	/**
	 * @param clazz                    clz
	 */
	protected void initImportList(Class<?> clazz) {
		importList.add(Autowired.class.getName());
		importList.add(clazz.getName());
		importList.add(modelClass.getName());
		importList.add(Api.class.getName());
		importList.add(HttpBodyHandler.class.getName());
		importList.add(ApiOperation.class.getName());
	}
	
	/**
	 * @param packageName              pkg
	 */
	protected void addImport(String packageName) {
		if (!importList.contains(packageName) &&
				!packageName.startsWith("java.lang") &&
				packageName.indexOf(".") != -1) {
			importList.add(packageName);
		}
	}
	
	/**
	 * @return                         imports
	 */
	protected String getImports() {
		StringBuffer sb = new StringBuffer();
		for (String im: importList) {
			sb.append(IMPORT.replace("IMPORT_NAME", im));
		}
		return sb.toString();
	}

	/*******************************************
	 * 
	 *    Field 
	 * 
	 *******************************************/
	
	/**
	 * @param clazz                    clz
	 * @return                         name
	 */
	private String fieldName(Class<?> clazz) {
		return clazz.getSimpleName().substring(0, 1).toLowerCase() 
				+ clazz.getSimpleName().substring(1);
	}
	
	/*******************************************
	 * 
	 *    Methods 
	 * 
	 *******************************************/
	
	/**
	 * @param clazz                      clz
	 * @return                           sb
	 * @throws Exception                 exception
	 */
	protected StringBuffer genrateMethods(Class<?> clazz) throws Exception {

		StringBuffer msb = new StringBuffer();
		
		for (Method method : clazz.getDeclaredMethods()) {
			
			String methodName = method.getName();
			if (methodName.endsWith("Count")) {
				continue;
			}
			
			
			String countName = methodName + "Count";
			boolean isFillUp = false;
			
			for (Method mm : clazz.getDeclaredMethods()) {
				if (countName.equals(mm.getName())) {
					isFillUp = true;
					break;
				}
			}
			// return
			ApiOperation fd = method.getAnnotation(ApiOperation.class);
			msb.append("\t@ApiOperation(shortName = \"" + fd.value() + "\", ")
				.append("desc = \"" + fd.notes())
				.append(")\n");
			if (isFillUp) {
				msb.append(METHOD.replace("METHOD_TYPE", Map.class.getName() + "<String, Object>")
						.replace("METHOD_NAME", methodName));
			} else {
				msb.append(METHOD.replace("METHOD_TYPE", method.getGenericReturnType().getTypeName())
						.replace("METHOD_NAME", methodName));
			}
			
			
			// method name
			StringBuffer psb = new StringBuffer();
			for (Parameter param : method.getParameters()) {
				if (isFillUp && (param.getName().equals("from")
						|| param.getName().equals("to"))) {
					continue;
				}
				
				addImport(param.getType().getTypeName());
				psb.append(param.getName() + ", ");
				
				
				if (param.getType().getName().equals(
								modelClass.getName())) {
					addImport(Valid.class.getPackage().getName() + ".*");
					msb.append("@Valid " + param.getType().getSimpleName() 
										+ " " + param.getName() + ", ");
				} else {
					addImport(Max.class.getPackage().getName() + ".*");
//					Field field = getModelClass().getDeclaredField(param.getName());
//					customized(msb, field);
//					jsr303(msb, field);
					msb.append(param.getType().getSimpleName() + " " + param.getName() + ", ");
				}
			}

			
			if (isFillUp) {
				msb.append("int number, int page  ");
			}
			
			if (psb.length() > 2) {
				psb.delete(psb.length() - 2, psb.length());
				msb.delete(msb.length() - 2, msb.length());
			}
			
			msb.append(END_PARAM);
			
			// method body
			if (!method.getReturnType().getSimpleName().equals("void")
					&& !isFillUp) {
				msb.append(RETURN);
			} else {
				msb.append(VOID);
			}
			
			if (isFillUp) {
				String paramStr = "(";
				for (Parameter param : method.getParameters()) {
					if (param.getName().equals("from") || param.getName().equals("to")) {
						continue;
					}
					paramStr += param.getName() + ", ";
				}
				String simpleName = clazz.getSimpleName();
				msb.append(FULLPROXY.replaceAll("TARGET", simpleName.substring(0, 1).toLowerCase()
															+ simpleName.substring(1))
						.replace("TOTAL_NUMBER", methodName + "Count" 
								+ paramStr.substring(0, paramStr.length() - 2) + ")")
						.replace("TOTAK_DATA", methodName+  
								paramStr.substring(0, paramStr.length()) + "from, to)"));
			} else {
				msb.append(PROXY.replace("PROXY_NAME", fieldName(clazz))
					.replace("PROXY_METHOD", methodName)
					.replace("PROXY_PARAM", psb.toString()));
			}
			
			// method complete
			msb.append(END_METHOD);
		}
		return msb;
	}

	/*******************************************
	 * 
	 *    JSR303 
	 * 
	 *******************************************/
	
	/**
	 * @param msb                         msb
	 * @param field                       field
	 */
	private void jsr303(StringBuffer msb, Field field) {
		if (field.getAnnotation(Null.class) != null) {
			msb.append("@Null ");
		} else if (field.getAnnotation(NotNull.class) != null) {
			msb.append("@NotNull ");
		} else if (field.getAnnotation(AssertTrue.class) != null) {
			msb.append("@AssertTrue ");
		} else if (field.getAnnotation(AssertFalse.class) != null) {
			msb.append("@AssertFalse ");
		} else if (field.getAnnotation(Pattern.class) != null) {
			msb.append("@Pattern(" + field.getAnnotation(Pattern.class).regexp() + ") ");
		} else if (field.getAnnotation(Min.class) != null) {
			msb.append("@Min(" + field.getAnnotation(Min.class).value() + ") ");
		} else if (field.getAnnotation(Max.class) != null) {
			msb.append("@Max(" + field.getAnnotation(Max.class).value() + ") ");
		} else if (field.getAnnotation(DecimalMin.class) != null) {
			msb.append("@DecimalMin(" + field.getAnnotation(DecimalMin.class).value() + ") ");
		} else if (field.getAnnotation(DecimalMax.class) != null) {
			msb.append("@DecimalMax(" + field.getAnnotation(DecimalMax.class).value() + ") ");
		} else if (field.getAnnotation(Size.class) != null) {
			msb.append("@Size(min = " + field.getAnnotation(Size.class).min() +", max = "
						+ field.getAnnotation(Size.class).max() + ") ");
		} else if (field.getAnnotation(Digits.class) != null) {
			msb.append("@Digits(integer = " + field.getAnnotation(Digits.class).integer() +", fraction = "
					+ field.getAnnotation(Digits.class).fraction() + ") ");
		} else if (field.getAnnotation(Past.class) != null) {
			msb.append("@Past ");
		} else if (field.getAnnotation(Future.class) != null) {
			msb.append("@Future ");
		} 
	}

	
	public static void main(String[] args) throws Exception {
		ServiceGenerator sg = new ServiceGenerator();
		sg.createServiceFromMapper("dev.examples.mysql.mappers.UserMapper");
		sg.print();
	}
	
}
